set nocompatible
filetype off

"{{{ PLUGINS
call plug#begin()
Plug 'preservim/nerdtree',          { 'on': ['NERDTreeToggle', 'NERDTreeFind'] }
Plug 'tpope/vim-abolish'            "toggle casing (snake or camel) with crs and crc
Plug 'tpope/vim-surround'           "provides mappings to surround stuff with stuff
Plug 'tpope/vim-commentary'         "mappings to comment/uncomment blocks of code
Plug 'tpope/vim-repeat'             "enables repeating commands from plugins
Plug 'majutsushi/tagbar'
Plug 'junegunn/fzf.vim'
Plug 'junegunn/fzf',                { 'do': { -> fzf#install() } }
Plug 'tpope/vim-projectionist',     { 'for': ['go', 'cpp', 'javascript', 'yaml'] }
Plug 'cespare/vim-toml',            { 'for': 'toml' }
Plug 'davidhalter/jedi-vim',        { 'for': 'python' }
Plug 'digitaltoad/vim-pug',         { 'for': ['pug', 'jade', 'vue'] }
Plug 'leafgarland/typescript-vim',  { 'for': 'typescript' }
Plug 'peitalin/vim-jsx-typescript', { 'for': 'typescriptreact' }
Plug 'pangloss/vim-javascript',     { 'for': 'javascript' }
Plug 'plasticboy/vim-markdown',     { 'for': 'markdown' }
Plug 'jparise/vim-graphql',         { 'for': 'graphql' }
Plug '~/dev/vim-cargo-search',      { 'for': 'rust' }
Plug '~/dev/LanguageClient-neovim'
Plug 'machakann/vim-highlightedyank'
Plug 'Shougo/neosnippet.vim'
Plug 'Shougo/neosnippet-snippets'
Plug 'ervandew/supertab'
Plug 'roxma/nvim-yarp'
Plug 'ncm2/ncm2'
Plug 'ncm2/ncm2-bufword'
Plug 'ncm2/ncm2-path'
Plug 'ncm2/ncm2-neosnippet'
Plug 'chriskempson/base16-vim'
Plug 'itchyny/lightline.vim'

" Plug 'vim-airline/vim-airline'
" Plug 'lifepillar/vim-mucomplete'
" Plug 'dense-analysis/ale'
" Plug 'schickling/vim-bufonly'
" Plug 'tpope/vim-fugitive'
" Plug 'fatih/vim-go',                { 'for': 'go' }
call plug#end()
"}}}

filetype plugin indent on

"{{{ GENERAL
syntax on
set binary
set noshowmatch " this doesn't work on OSX, DisableMatchParen achieves the same
set nomodeline
set lazyredraw
set shortmess+=c
set more
set timeoutlen=1000 ttimeoutlen=0
set encoding=utf-8
set shell=/usr/local/bin/fish
set number relativenumber
set guifont=monospace
set nobackup
set hidden
set noswapfile
" set textwidth=100
set belloff=all
set signcolumn=yes
set tabstop=2
set shiftwidth=2
set expandtab
set backspace=indent,eol,start
set autoindent
set pastetoggle=<leader>z
" set clipboard=unnamed
set ignorecase
set history=100
set hlsearch
set showmatch
set wildmenu
set updatetime=300
set autoread
set ttyfast
set mouse=a
let mapleader = ','
let maplocalleader = "\\"
let g:ftplugin_sql_omni_key = '<C-j>'
let g:loaded_python_provider = 0
let g:loaded_ruby_provider = 0
let g:loaded_node_provider = 0
let g:ruby_host_prog='/Users/martin/.gem/ruby/2.7.0/bin/neovim-ruby-host'
let g:python3_host_prog='/usr/local/bin/python3'
" let g:python2_host_prog='/usr/bin/python'
let netrw_altfile = 1
"}}}

" {{{ COLORS
set background=dark
if has('nvim')
  colorscheme base16-gruvbox-dark-hard
  set termguicolors
endif

hi Normal                 guibg=#0B0B0B
hi Todo                   ctermbg=none ctermfg=yellow guibg=none guifg=#fabd2f
hi Error                  ctermbg=none ctermfg=red guibg=none guifg=red
hi LCNCodeLens            ctermfg=14 ctermbg=none guibg=none guifg=#00D7FF
hi ExtraWhitespace        ctermbg=red

" match ExtraWhitespace /\s\+$/
" augroup whitespace
"   autocmd!
"   autocmd BufWinEnter * match ExtraWhitespace /\s\+$/
"   autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
"   autocmd InsertLeave * match ExtraWhitespace /\s\+$/
"   autocmd BufWinLeave * call clearmatches()
" augroup END
""}}}

"" {{{ LCN
augroup LanguageClientConfig
  autocmd!
  autocmd BufRead,BufNewFile go.mod set filetype=gomod

  let gopls_config = {
        \ 'name': 'gopls',
        \ 'command': ['gopls'],
        \ 'initializationOptions': {
        \  'usePlaceholders': v:true,
        \  'gofumpt': v:true,
        \  'codelens': {
        \   'test': v:true,
        \   'generate': v:true
        \  }
        \ }
        \}

  autocmd User LanguageClientStarted 
        \ let g:LanguageClient_fzfOptions = ['--delimiter', ':', '--preview-window', '+{2}-5'] + fzf#vim#with_preview().options
  let g:LanguageClient_windowLogMessageLevel = 'ERROR'
  let g:LanguageClient_loggingLevel = 'ERROR'
  let g:LanguageClient_loggingFile = '~/Desktop/lcn.log'
  let g:LanguageClient_hoverPreview = 'always'
  let g:LanguageClient_completionPreferTextEdit = 0
  let g:LanguageClient_useVirtualText = 'All'
  let g:LanguageClient_applyCompletionAdditionalTextEdits = 0
  let g:LanguageClient_hideVirtualTextsOnInsert = 1
  let g:LanguageClient_serverCommands = {}
  let g:LanguageClient_serverCommands.python = ['pyls']
  let g:LanguageClient_serverCommands.cpp = ['ccls']
  let g:LanguageClient_serverCommands.javascript = ['javascript-typescript-stdio']
  let g:LanguageClient_serverCommands.typescript = ['javascript-typescript-stdio']
  let g:LanguageClient_serverCommands.rust = ['rust-analyzer']
  let g:LanguageClient_serverCommands.gomod = gopls_config
  let g:LanguageClient_serverCommands.go = gopls_config
  
	let g:LanguageClient_codeLensDisplay = {
        \ 'texthl': 'CodeLens',
        \ 'signTexthl': 'LCNInfo',
        \ 'signText': '🔍',
        \ 'virtualTexthl': 'LCNCodeLens',
        \ }

	let g:LanguageClient_diagnosticsDisplay = {
  			\ 1: { 'signTexthl': 'ErrorSign' },
  			\ 2: { 'signTexthl': 'WarningSign' },
        \ }

  function! WorkspaceSymbols()
    let query = input('Enter query: ')
    call LanguageClient#workspace_symbol(query)
  endfunction

  function! LCNMappings()
    if !LanguageClient#HasCommand(&filetype)
      return
    endif

    nmap <buffer> <silent><F5>         <Plug>(lcn-menu)
    nmap <buffer> <silent>K            <Plug>(lcn-hover)
    nmap <buffer> <silent>R            <Plug>(lcn-rename)
    nmap <buffer> <silent>E            <Plug>(lcn-explain-error)
    nmap <buffer> <silent>gd           <Plug>(lcn-definition)
    nmap <buffer> <silent>gD           <c-w>v<Plug>(lcn-definition)
    nmap <buffer> <silent>gr           <Plug>(lcn-references)
    nmap <buffer> <silent>gi           <Plug>(lcn-implementation)
    nmap <buffer> <silent>ga           <Plug>(lcn-code-action)
    vmap <buffer> <silent>ga           <Plug>(lcn-code-action)
    nmap <buffer> <silent>gl           <Plug>(lcn-code-lens-action)
    nmap <buffer> gws                  :call WorkspaceSymbols()<CR>
    nmap <buffer> <silent>F            <Plug>(lcn-format-sync)
    nmap <buffer> <silent><c-s><c-s>   <Plug>(lcn-highlight)
    nmap <buffer> <silent><c-s><c-h>   :call LanguageClient#clearDocumentHighlight()<CR>
    nmap <buffer> <silent><c-]>        <Plug>(lcn-diagnostics-next)
    nmap <buffer> <silent><c-[>        <Plug>(lcn-diagnostics-prev)
  endfunction

  autocmd FileType * call LCNMappings()

  command! LanguageClientRestart call LanguageClientRestart()
augroup END
"" }}}

"{{{ NERDTREE
let g:NERDTreeQuitOnOpen = 1
let g:NERDTreeMinimalUI = 1
let g:NERDTreeAutoDeleteBuffer = 1
map <leader>r :NERDTreeFind<cr>
map <C-n> :NERDTreeToggle<CR>
map <silent>- :call ToggleTree()<CR>
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif " close vim if nerdtre is only open win

function! ToggleTree()
  if &filetype == ''
    :NERDTreeToggle
  elseif &filetype == 'nerdtree' || exists("g:NERDTree") && g:NERDTree.IsOpen()
    :call nerdtree#ui_glue#upDir(v:true)
  else
		:NERDTreeFind
    " :NERDTreeToggle %
  endif
endfunction
"}}}

"{{{ TAGBAR
let g:tagbar_foldlevel = 0
let g:tagbar_sort = 0
nmap <silent>,. :TagbarToggle<CR><C-w><C-w>
"}}}

" {{{ FZF
" imap <c-x><c-k> <plug>(fzf-complete-word)
" imap <c-x><c-f> <plug>(fzf-complete-path)
" imap <c-x><c-l> <plug>(fzf-complete-line)
nmap <leader><tab> <plug>(fzf-maps-n)
nmap <c-p> :Files<CR>

let g:fzf_preview_window = []
command! -bang -nargs=* Rg call fzf#vim#grep("rg --column --line-number --no-heading --color=always --smart-case ".<q-args>, <bang>0)
" command! -bang -nargs=? -complete=dir Files
"  \ call fzf#vim#files(<q-args>, fzf#vim#with_preview(), <bang>0)
" }}}

" {{{ MAPPINGS
command! WQ wq
command! Wq wq
command! W w
command! Q q
command! BufOnly execute '%bd|e#|bd#'
command! ProfileStart :call ProfileStart()
command! ProfileStop :call ProfileStop()
command! Gblame normal!:let @a=expand('%')<CR>:let @b=line('.')<CR>:80vnew<CR>:set bt=nofile<CR>:set nowrap<CR>:%!git blame -wM <C-R>a<CR>:<C-R>b<CR>

nnoremap <silent> <C-h> :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>
nnoremap gev :e ~/.config/nvim/init.vim<CR>
nnoremap gsv :so ~/.config/nvim/init.vim<CR>
nnoremap <LeftMouse> <NOP>
nnoremap <Left> <NOP>
nnoremap <Right> <NOP>
nnoremap <Up> <NOP>
nnoremap <Down> <NOP>
nmap <tab> :bnext<CR>
nmap <s-tab> :bprevious<CR>
nmap <c-f> :Rg<space>
nmap <leader>ba :bufdo bd<CR>
nmap <silent><leader>bo :BufOnly<CR>
nmap <leader>x :%!xxd<CR>
nmap <C-v><C-v> gg<C-V>G$
nmap <c-s><c-v> :vsplit<CR>
nmap <c-s><c-h> :split<CR>
nmap <Right> :cnext<cr>
nmap <Left> :cprevious<cr>
nmap <space><space> <C-^>
inoremap <C-c> <ESC>
inoremap <LeftMouse> <NOP>
vnoremap <leader>pj :!python -m json.tool<CR>
nmap <silent> ]p :pu<CR>
nmap <silent> [p :pu!<CR>

function! ProfileStart()
  :profile start profile.log
  :profile func *
  :profile file *
endfunction

function! ProfileStop()
  :profile stop
endfunction
"}}}

"" {{{ PROJECTIONIST
nmap <silent><leader>aa :A<CR>
nmap <silent><leader>av :AV<CR>

augroup projection_extension
  autocmd User ProjectionistDetect
  \ call projectionist#append(getcwd(),
  \ {
  \    '*.go':      { 'alternate': '{}_test.go' },
  \    '*_test.go': { 'alternate': '{}.go' },
  \    '*.cpp':     { 'alternate': '{}.h' },
  \    '*.h':       { 'alternate': '{}.cpp' },
  \    '*.js':      { 'alternate': '{}.spec.js' },
  \    '*.spec.js': { 'alternate': '{}.js' }
  \ })
augroup END
"" }}}

" {{{ VIM-MARKDOWN
let g:vim_markdown_fenced_languages = ['rust', 'go']
" }}}

" {{{ COMPLETION
" set completeopt=noinsert,menuone,noselect
" let g:neosnippet#enable_completed_snippet = 1
" " let g:neosnippet#enable_complete_done = 1

" function! ExpandSnippetOrCompletionItem()
"   let cur_text = neosnippet#util#get_cur_text()
"   let cur_col = col('.')

"   if v:completed_item['user_data'] ==# ''
"     call mucomplete#neosnippet#expand_snippet("\<cr>")
"   else
"     call neosnippet#mappings#_complete_done(cur_text, cur_col)
"   endif
" endfunction

" let g:mucomplete#enable_auto_at_startup = 1
" let g:mucomplete#always_use_completeopt = 1
" let g:mucomplete#completion_delay = 50
" let g:mucomplete#chains = { 'default' : ['omni', 'nsnp'] }
" imap <C-k>     <Plug>(neosnippet_expand_target)
" smap <C-k>     <Plug>(neosnippet_expand_or_jump)
" xmap <C-k>     <Plug>(neosnippet_expand_target)
" imap <expr><C-k> pumvisible() ?
" 	\ timer_start(0, { -> ExpandSnippetOrCompletionItem() })
" 	\ : "\<Plug>(neosnippet_expand_or_jump)"

" imap <expr><C-k> pumvisible() ?
" 	\ mucomplete#neosnippet#expand_snippet("\<cr>")
" 	\ : "\<Plug>(neosnippet_expand_or_jump)"

set completeopt=noinsert,menuone,noselect
let g:neosnippet#enable_completed_snippet = 1
let g:neosnippet#enable_complete_done = 1

autocmd BufEnter * call ncm2#enable_for_buffer()
let g:ncm2#auto_popup = 1
imap <C-k>     <Plug>(neosnippet_expand_target)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)
imap <expr><C-k> pumvisible() ?
	\ ncm2_neosnippet#expand_or("", 'n')
	\ : "\<Plug>(neosnippet_expand_or_jump)"
" }}}

" {{{ SUPERTAB
let g:SuperTabDefaultCompletionType = '<c-n>'
" }}}

"" {{{ ALE
"" nmap <silent>E    :ALEDetail<CR>
"nmap <C-[>        :ALEPrevious<CR>
"nmap <C-]>        :ALENext<CR>

"let g:ale_fixers = {
"      \ 'rust': ['rustfmt'],
"      \ 'javascript': ['eslint'],
"      \ 'typescript.tsx': ['eslint'],
"      \ 'typescript': ['eslint']
"      \}

"let g:airline#extensions#ale#enabled = 0
"let g:ale_echo_cursor = 1
"let g:ale_set_loclist = 0
"let g:ale_set_quickfix = 0
"let g:ale_completion_enabled = 0
"let g:ale_disable_lsp = 1
"let g:ale_fix_on_save = 1
"let g:ale_lint_on_enter = 1
"let g:ale_emit_conflict_warnings = 1
"let g:ale_linters = {
"      \ 'go': ['LanguageClientNeovim'],
"      \ 'rust': ['rustc'],
"      \ 'javascript': ['eslint'],
"      \ 'typescript': ['tslint']
"      \}
""}}}

" {{{ LIGHTLINE
function! LCNStatus() abort
	let l:running = LanguageClient#isServerRunning()
	if l:running
		return 'LCN: ✔'
	endif

	return 'LCN: ✘'
endfunction

let g:lightline = {
      \ 'active': {
      \   'left': [ [ 'mode', 'paste' ],
      \             [ 'lcn-status', 'readonly', 'filename', 'modified' ] ],
			\ 'right': 	[ [ 'lineinfo' ],
			\ 						[ 'percent' ],
      \             [ 'fileformat', 'fileencoding', 'filetype', 'charvaluehex' ] ]
      \ },
      \ 'component_function': {
      \   'lcn-status': 'LCNStatus',
      \   'gitbranch': 'GitBranch'
      \ },
      \ }
" }}}

" match paren is extremely slow on OSX, disable it
function! g:DisableMatchParen ()
    if exists(":NoMatchParen")
        :NoMatchParen
    endif
endfunction

augroup plugin_initialize
    autocmd!
    autocmd VimEnter * call DisableMatchParen()
augroup END
    autocmd BufReadPost *.re setlocal filetype=reason
